package ateamproject.kezuino.com.github.singleplayer;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.maps.MapProperties;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.TiledMapTileSet;
import com.badlogic.gdx.maps.tiled.TmxMapLoader;
import com.badlogic.gdx.utils.JsonReader;
import com.badlogic.gdx.utils.JsonValue;
import javafx.beans.property.MapProperty;
import jdk.nashorn.internal.parser.JSONParser;
import jdk.nashorn.internal.runtime.Source;

import java.io.File;
import java.util.*;

public class Map {
    /**
     * LibGDX 2D {@link TiledMap} for rendering purposes.
     */
    private TiledMap baseMap;
    /**
     * X dimension of the size of this {@link Map}.
     */
    private int width;
    /**
     * Y dimension of the size of this {@link Map}.
     */
    private int height;
    /**
     * All the {@link Node nodes} on this {@link Map}.
     */
    private Nodes nodes;
    /**
     * {@link GameSession} that hosts the {@link Map} and allows multiplayer.
     */
    private GameSession gameSession;
    /**
     * Initializes a map with a 2D array filled with {@link Node nodes}.
     *
     * @param session    {@link GameSession} that will host this @see Map.
     * @param squareSize Width and height dimension length.
     */
    public Map(GameSession session, int squareSize) {
        this(session, squareSize, squareSize);
    }

    /**
     * Initializes a {@link Map} with a 2D array filled with {@link Node nodes}.
     *
     * @param session {@link GameSession} that will host this {@link Map}.
     * @param width   X dimension of the map.
     * @param height  Y dimension of the map.
     */
    public Map(GameSession session, int width, int height) {
        gameSession = session;
        this.width = width;
        this.height = height;

        nodes = new Nodes(width, height);
        resetNodes(width, height);
    }

    /**
     * Initializes a {@link Map} using the .TMX file generated by Tiled.
     *
     * @param session
     * @param mapPath
     * @return
     */
    public static Map load(GameSession session, String mapPath) {
        if (mapPath == null || mapPath.isEmpty()) throw new IllegalArgumentException();

        TmxMapLoader.Parameters parms = new TmxMapLoader.Parameters();
        parms.textureMinFilter = Texture.TextureFilter.Nearest;
        parms.textureMagFilter = Texture.TextureFilter.Nearest;
        TiledMap tiledMap = new TmxMapLoader().load(mapPath, parms);
        MapProperties props = tiledMap.getProperties();
        Map map = new Map(session, props.get("width", Integer.class), props.get("height", Integer.class));
        map.baseMap = tiledMap;

        TiledMapTileLayer layer = (TiledMapTileLayer) map.baseMap.getLayers().get(0);
        for (int x = 0; x < map.width; x++) {
            for (int y = 0; y < map.height; y++) {
                Node node = map.getNode(x, y);
                node.setTileId(layer.getCell(x, y).getTile().getId());
            }
        }
        
        // TODO: Create GameObjects from the second layer.
        

        return map;
    }

    public TiledMap getBaseMap() {
        return baseMap;
    }

    /**
     * Returns the {@link Node} count that this map has.
     *
     * @return Amount of nodes used by this map.
     */
    public int getSize() {
        return getWidth() * getHeight();
    }

    /**
     * X dimension of the size of this {@link Map}.
     *
     * @return number of {@link Node nodes} that this {@link Map} is in the X dimension.
     */
    public int getWidth() {
        return width;
    }

    /**
     * Y dimension of the size of this {@link Map}.
     *
     * @return number of {@link Node nodes} that this {@link Map} is in the Y dimension.
     */
    public int getHeight() {
        return height;
    }

    /**
     * Resets the 2D array to the new dimensions.
     *
     * @param width  X dimension of the {@link Map}.
     * @param height Y dimension of the {@link Map}.
     */
    protected void resetNodes(int width, int height) {
        this.width = width;
        this.height = height;
        nodes = new Nodes(width, height);
        resetNodes();
    }

    /**
     * Resets the 2D array based on the current {@link #width} and {@link #height}.
     */
    protected void resetNodes() {
        baseMap = new TiledMap();
        TiledMapTileLayer layer = new TiledMapTileLayer(width, height, 32, 32);
        baseMap.getLayers().add(layer);

        for (int x = 0; x < nodes.getLength(); x++) {
            for (int y = 0; y < nodes.getLength(x); y++) {
                nodes.set(x, y, new Node(this, x, y));
                layer.setCell(x, y, nodes.get(x, y));
            }
        }
    }

    /**
     * Returns a {@link Node} if found, else it will return null.
     *
     * @param x position to get {@link Node} from.
     * @param y position to get {@link Node} from.
     * @return {@link Node} if {@code x} and {@code y} are in-bounds. Null otherwise.
     */
    public Node getNode(int x, int y) {
        if (x >= 0 && y >= 0 && x < width && y < height) {
            return nodes.get(x, y);
        }
        return null;
    }

    /**
     * Returns all {@link GameObject gameobjects} within a {@link Map}.
     */
    public List<GameObject> getAllGameObjects() {
        List<GameObject> objs = new ArrayList<>();
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                Node node = getNode(x, y);
                objs.addAll(node.getGameObjects());
            }
        }
        return objs;
    }

    /**
     * Returns a node which is in the direction of the given direction. Will return null if node does not exist.
     *
     * @param node
     * @param direction
     */
    public Node getAdjecentNode(Node node, Direction direction) {
        if (node == null) throw new NullPointerException("Parameter node must not be null.");
        if (direction == null) throw new NullPointerException("Parameter direction must not be null.");
        switch (direction) {
            case Up:
                return getNode(node.getX(), node.getY() - 1);
            case Down:
                return getNode(node.getX(), node.getY() + 1);
            case Left:
                return getNode(node.getX() - 1, node.getY());
            case Right:
                return getNode(node.getX() + 1, node.getY());
            default:
                return null;
        }
    }

    /**
     * Adds a {@link GameObject} to a position on this {@link Map}.
     *
     * @param object to add to a {@link ateamproject.kezuino.com.github.singleplayer.Node} on this {@link ateamproject.kezuino.com.github.singleplayer.Map}.
     * @return {@link GameObject} that was added to the {@link Map}.
     */
    public GameObject addGameObject(int x, int y, GameObject object) {
        getNode(x, y).addGameObject(object);
        object.setPosition(x, y);
        object.setMap(this);
        return object;
    }

    /**
     * Gets all the {@link Node nodes} of this {@link Map}.
     *
     * @return All the {@link Node nodes} of this {@link Map}.
     */
    public Nodes getNodes() {
        return nodes;
    }
}